-- test normal function
create function testfunc(username text, id integer, data text)
returns text as $$ cluster 'testcluster'; run on hashtext(username); $$ language plproxy;
\c test_part
create function testfunc(username text, id integer, data text)
returns text as $$ begin return 'username=' || username; end; $$ language plpgsql;
\c regression
select * from testfunc('user', 1, 'foo');
   testfunc    
---------------
 username=user
(1 row)

select * from testfunc('user', 1, 'foo');
   testfunc    
---------------
 username=user
(1 row)

select * from testfunc('user', 1, 'foo');
   testfunc    
---------------
 username=user
(1 row)

-- test setof text
create function test_set(username text, num integer)
returns setof text as $$ cluster 'testcluster'; run on hashtext(username); $$ language plproxy;
\c test_part
create function test_set(username text, num integer)
returns setof text as $$
declare i integer;
begin
    i := 0;
    while i < num loop
        return next 'username=' || username || ' row=' || i;
        i := i + 1;
    end loop;
    return;
end; $$ language plpgsql;
\c regression
select * from test_set('user', 1);
      test_set       
---------------------
 username=user row=0
(1 row)

select * from test_set('user', 0);
 test_set 
----------
(0 rows)

select * from test_set('user', 3);
      test_set       
---------------------
 username=user row=0
 username=user row=1
 username=user row=2
(3 rows)

-- test record
create type ret_test_rec as ( id integer, dat text);
create function test_record(username text, num integer)
returns ret_test_rec as $$ cluster 'testcluster'; run on hashtext(username); $$ language plproxy;
\c test_part
create type ret_test_rec as ( id integer, dat text);
create function test_record(username text, num integer)
returns ret_test_rec as $$
declare ret ret_test_rec%rowtype;
begin
    ret := (num, username);
    return ret;
end; $$ language plpgsql;
\c regression
select * from test_record('user', 3);
 id | dat  
----+------
  3 | user
(1 row)

-- test setof record
create function test_record_set(username text, num integer)
returns setof ret_test_rec as $$ cluster 'testcluster'; run on hashtext(username); $$ language plproxy;
\c test_part
create function test_record_set(username text, num integer)
returns setof ret_test_rec as $$
declare ret ret_test_rec%rowtype; i integer;
begin
    i := 0;
    while i < num loop
        ret := (i, username);
        i := i + 1;
        return next ret;
    end loop;
    return;
end; $$ language plpgsql;
\c regression
select * from test_record_set('user', 1);
 id | dat  
----+------
  0 | user
(1 row)

select * from test_record_set('user', 0);
 id | dat 
----+-----
(0 rows)

select * from test_record_set('user', 3);
 id | dat  
----+------
  0 | user
  1 | user
  2 | user
(3 rows)

-- test void
create function test_void(username text, num integer)
returns void as $$ cluster 'testcluster'; run on hashtext(username); $$ language plproxy;
\c test_part
create function test_void(username text, num integer)
returns void as $$
begin
    return;
end; $$ language plpgsql;
-- look what void actually looks
select * from test_void('void', 2);
 test_void 
-----------
 
(1 row)

select test_void('void', 2);
 test_void 
-----------
 
(1 row)

\c regression
select * from test_void('user', 1);
 test_void 
-----------
 
(1 row)

select * from test_void('user', 3);
 test_void 
-----------
 
(1 row)

select test_void('user', 3);
 test_void 
-----------
 
(1 row)

select test_void('user', 3);
 test_void 
-----------
 
(1 row)

-- test normal outargs
create function test_out1(username text, id integer, out data text)
as $$ cluster 'testcluster'; run on hashtext(username); $$ language plproxy;
\c test_part
create function test_out1(username text, id integer, out data text)
returns text as $$ begin data := 'username=' || username; return; end; $$ language plpgsql;
\c regression
select * from test_out1('user', 1);
     data      
---------------
 username=user
(1 row)

-- test complicated outargs
create function test_out2(username text, id integer, out out_id integer, xdata text, inout xdata2 text, out odata text)
as $$ cluster 'testcluster'; run on hashtext(username); $$ language plproxy;
\c test_part
create function test_out2(username text, id integer, out out_id integer, xdata text, inout xdata2 text, out odata text)
as $$ begin
    out_id = id;
    xdata2 := xdata2 || xdata;
    odata := 'username=' || username;
    return;
end; $$ language plpgsql;
\c regression
select * from test_out2('user', 1, 'xdata', 'xdata2');
 out_id |   xdata2    |     odata     
--------+-------------+---------------
      1 | xdata2xdata | username=user
(1 row)

-- test various types
create function test_types(username text, inout vbool boolean, inout xdate timestamp, inout bin bytea)
as $$ cluster 'testcluster'; run on hashtext(username); $$ language plproxy;
\c test_part
create function test_types(username text, inout vbool boolean, inout xdate timestamp, inout bin bytea)
as $$ begin return; end; $$ language plpgsql;
\c regression
select * from test_types('types', true, '2009-11-04 12:12:02', E'a\\000\\001\\002b');
 vbool |          xdate           |      bin       
-------+--------------------------+----------------
 t     | Wed Nov 04 12:12:02 2009 | a\000\001\002b
(1 row)

select * from test_types('types', NULL, NULL, NULL);
 vbool | xdate | bin 
-------+-------+-----
       |       | 
(1 row)

-- test user defined types
create domain posint as int4 check (value > 0);
create type struct as (id int4, data text);
create function test_types2(username text, inout v_posint posint, inout v_struct struct, inout arr int8[])
as $$ cluster 'testcluster'; run on 0; $$ language plproxy;
\c test_part
create domain posint as int4 check (value > 0);
create type struct as (id int4, data text);
create function test_types2(username text, inout v_posint posint, inout v_struct struct, inout arr int8[])
as $$ begin return; end; $$ language plpgsql;
\c regression
select * from test_types2('types', 4, (2, 'asd'), array[1,2,3]);
 v_posint | v_struct |   arr   
----------+----------+---------
        4 | (2,asd)  | {1,2,3}
(1 row)

select * from test_types2('types', NULL, NULL, NULL);
 v_posint | v_struct | arr 
----------+----------+-----
          | (,)      | 
(1 row)

-- test CONNECT
create function test_connect1() returns text
as $$ connect 'dbname=test_part'; select current_database(); $$ language plproxy;
select * from test_connect1();
 test_connect1 
---------------
 test_part
(1 row)

-- test timeout
create or replace function
plproxy.get_cluster_config(cluster_name text, out key text, out val text)
returns setof record as $$
begin
    key := 'statement_timeout';
    val := 10; -- ms
    return next;
    return;
end; $$ language plpgsql;
create or replace function plproxy.get_cluster_version(cluster_name text)
returns integer as $$
begin
    if cluster_name = 'testcluster' then
        return 6;
    end if;
    raise exception 'no such cluster: %', cluster_name;
end; $$ language plpgsql;
create function test_timeout()
returns text as $$
    cluster 'testcluster';
    run on 0;
    select 'asd' from pg_sleep(3);
$$ language plproxy;
select * from test_timeout();
ERROR:  PL/Proxy function public.test_timeout(0): remote error: ERROR:  canceling statement due to statement timeout

create or replace function
plproxy.get_cluster_config(cluster_name text, out key text, out val text)
returns setof record as $$
begin
    key := 'statement_timeout';
    val := 0;
    return next;
    return;
end; $$ language plpgsql;
create or replace function plproxy.get_cluster_version(cluster_name text)
returns integer as $$
begin
    if cluster_name = 'testcluster' then
        return 7;
    end if;
    raise exception 'no such cluster: %', cluster_name;
end; $$ language plpgsql;
-- test quoting function
create type "RetWeird" as (
    "ColId" int4,
    "ColData" text
);
create function "testQuoting"(username text, id integer, data text)
returns "RetWeird" as $$ cluster 'testcluster'; run on hashtext(username); $$ language plproxy;
\c test_part
create type "RetWeird" as (
    "ColId" int4,
    "ColData" text
);
create function "testQuoting"(username text, id integer, data text)
returns "RetWeird" as $$ select 1::int4, 'BazOoka'::text $$ language sql;
\c regression
select * from "testQuoting"('user', '1', 'dat');
 ColId | ColData 
-------+---------
     1 | BazOoka
(1 row)

